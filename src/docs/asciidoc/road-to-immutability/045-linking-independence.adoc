[#linking-and-independence]
== Linking, independence, content

Let us now elaborate on how we will compute modifications, in a path towards level 2 immutability.
Consider the following example:

.Example {counter:example}, a field assigned to a constructor parameter
[source,java]
----
class LinkExample1<X> {
    private final Set<X> set;

    public LinkExample1(Set<X> xs) {
        this.set = xs;
    }

    public void add(X x) {
        set.add(x);
    }
}
----

After construction, an instance of `LinkExample1` contains a reference to the set that was passed on as an argument to its constructor.
We say the field `set` links to the parameter `xs` of the constructor.
In this example, this is an expensive way of saying that there is an assignment from one to the other.
However, linking can become more complicated.

The {e2immu} analyser will add modification annotations to `LinkExample1` as follows:

.Example {counter:example}, a field linked to a constructor parameter, with annotations
[source,java]
----
class LinkExample1<X> {
    @Modified
    private final Set<X> set;

    public LinkExample1(@Modified Set<X> xs) {
        this.set = xs;
    }

    @Modified
    public void add(X x) {
        set.add(x);
    }
}
----

The parameter `x` of `LinkExample1.add` is {nm} because the first parameter of `Set.add` is {nm}.
The `add` method modifies the field, which causes the annotation first on the method, then on the field, and finally on the parameter of the constructor.
Because of the latter, `LinkExample1` cannot be marked {container}.

Linking looks at the underlying object, and not at the variable.
Consider the following alternative `add` method:

.Example {counter:example}, alternative `add` method for `LinkExample1`
[source,java]
----
@Modified
public void add(X x) {
    Set<X> theSet = this.set;
    X theX = x;
    theSet.add(theX);
}
----

Nothing has changed, obviously.
Finally, as an example of how linking can become more complicated than following assignments, consider a typical _view_ on a collection:

.Example {counter:example}, linking using a method call
[source,java]
----
List<X> list = createSomeLargeList();
List<X> sub = list.subList(1, 5);
sub.set(0, x); // <1>
----

<1> The modifying method call `set` will modify `sub`, and `list` as well!

On the other side of the spectrum, linking does not work on objects that cannot be modified, like primitives or deeply immutable objects such as the primitives, or `java.lang.String`.

Let us summarize by:

****
*Definition*: Two objects are independent of each other when no modification to the first can imply a modification to the second.

Conversely, two objects are linked when a modification to the first may imply a modification to the second.
****

Linked objects typically share a common sub-object: the object returned by `subList`, for example, is "backed" by the original list, in other words, it maintains a reference to the original list.

We will discuss linking in more detail in <<computing-dependence>>.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that both variables represent (part of) the same object (their object graphs overlap).

Linking and independence is important when it occurs from fields to parameters and return values of methods:

****
*Definition*:
A method or constructor parameter is *independent* when it is independent of the fields of the type.
A method is *independent* when its return value is independent of the fields of the type.

The independence is marked with {independent} on the method for the return value, and on the relevant parameters otherwise.
****

When a constructor parameter is not independent, any modification made to the object presented to this parameter as an argument may have an influence on the object graph of the fields of the constructor's type.
But do all these modifications matter to the type?

We will try to make our case using two examples.
First, consider `Counter` and `Counters`:

.Example {counter:example}, Counter, Counters
[source,java]
----
interface Counter {
  void increment();
  int getValue();
  String getName();
}

class Counters {
  private final Map<String, Counter> counters;

  public Counters(Collection<Counter> counterCollection) {
    this.counters = counterCollection.stream().collect
      (Collectors.toUnmodifiableMap(Counter::getName, c -> c));
  }

  public Counter getCounter(String name) {
    return counters.get(name);
  }

  public int getValue(String name) {
    return getCounter(name).getValue();
  }

  public void increment(String name) {
    getCounter(name).increment();
  }

  public void incrementAll() {
    counters.values().forEach(Counter::increment);
  }
}
----

The constructor `Counters` copies every counter in the `counterCollection` into a new, unmodifiable map.
Clearly, external modifications to the collection itself (i.e., adding, removing a new `Counter` element) made after creation of the `Counters` object, will have no effect on the object graph of the field `counters`:

[source,java]
----
List<Counter> list = new ArrayList<>();
Collections.addAll(list, new CounterImpl("sunny days"), new CounterImpl("rainy days"));
Counters counters = new Counters(list);
Counter sunnyDays = list.remove(0);
assert "sunny days".equals(sunnyDays.getName());
assert sunnyDays == counters.getCounter("sunny days");
----

However, consider the following statements executed after creating a `Counters` object:

.Example {counter:example}, after creating a Counters object
[source,java]
----
int rainyDays = counters.getValue("rainy days");
Counter c = counters.get("rainy days");
c.increment();
assert c.getValue() == rainyDays + 1;
assert counters.getValue("rainy days") == rainyDays + 1;
----

An external modification (`c.increment()`) to an object presented to the constructor as part of the collection has an effect on the object graph of the fields, to the extent that an identical, non-modifying method call returns a different value!

We must conclude that the parameter of the constructor `counterCollection` is linked to the field `counters`, even if modifications at the collection level have no effect.

Now we put the `Counters` example in contrast with the `Levels` example, where the modifying method `increment()` has been removed from `Counter` to obtain `Level`:

.Example {counter:example}, Level, Levels
[source,java]
----
interface Level {
  int getValue();
  String getName();
}

class Levels {
  private final Map<String, Level> levels;

  public Levels(Collection<Level> levelCollection) {
    this.levels = levelCollection.stream().collect
      (Collectors.toUnmodifiableMap(Level::getName, c -> c));
  }

  public Level getLevel(String name) {
    return levels.get(name);
  }

  public int getValue(String name) {
    return getLevel(name).getValue();
  }
}
----

As a consequence of the absence of `increment()` in `Level`, we had to remove `increment()` and `incrementAll()` from `Levels` as well.
In fact, whether the `Level` instances are modifiable or not, does not seem to matter anymore to `Levels`.
