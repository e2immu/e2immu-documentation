[#higher-level-modifications]
== Abstract methods and higher-level modifications

From a type's point of view, fields are either of an explicit type, they are accessible, or they are of implicitly immutable type, in other words, replaceable by `Object` and inaccessible.
Our focus up to now has been on modification of the explicit types: we have argued that they are the only ones that matter for practical immutability.
Now we will try to characterise modifications that are beyond the scope of the type.

Please note that characterising _all_ modifications is a hopelessly complex, and unnecessary, task.
We will, however, need to deal with what can be seen as the first level of higher level modifications, if we want to be able to characterise the modifications going on in extremely important constructs such as iterators.

These observations occur naturally in the context of abstract methods: the specification of the `java.util.Collection` interface, or the functional interfaces like `java.util.function.Function`.

=== Setting the scene

The basis of this section is an example container class called `Circular`:

.First methods of Circular
[source,java]
----
@Container
class Circular<T> {

    private T x;
    private T y;
    private boolean next;

    public Circular() {
    }

    @Independent
    public Circular(Circular<T> c) {
        x = c.x;
        y = c.y;
        next = c.next;
    }

    @Modified
    public void add(T t) {
        if (next) {
            this.y = t;
        } else {
            this.x = t;
        }
        next = !next;
    }

    @NotModified
    @E2Container
    public Stream<T> stream() {
        return Stream.of(x, y);
    }
}
----

The `Circular` class is an extremely simple collection; it acts as a stand-in for many JDK collections like `java.util.List` or `java.util.Set`.
We also make use of the `Consumer` functional interface:

.Consumer
[source,java]
----
@FunctionalInterface
interface Consumer<T> {
    void accept(T t);
}
----

Note that method and parameter remain unmarked in terms of modification: we will accept the implicit `@Modified` annotation both on the `accept` method, and its parameter `t`.
Doing the opposite, i.e., specifying `@NotModified` on `accept`, would prohibit any implementation of `accept` from being modifying, which is overly restrictive.
Similarly, specifying `@NotModified` on `t` would exclude many valid implementations of the consumer concept.

Note that there are functional interfaces where `@NotModified` makes sense, e.g.,

.Comparable
[source,java]
----
interface Comparable<T> {
    @NotModified
    int compareTo(@NotModified T other);
}
----

While not explicitly marked as `@FunctionalInterface` in the JDK, `Comparable` has a single abstract method.
We expect comparisons to be non-modifiable, both with respect to the fields of the implementing type (this), as to the `other` object (that).

Using the `Consumer` we introduce a `forEach` method which iterates over the two elements:

.forEach in Circular
[source,java]
----
public void forEach(Consumer<T> consumer) {
    consumer.accept(x);
    consumer.accept(y);
}
----

Now we need to do some careful reasoning to determine the modification status of `forEach`, and to find out which annotation to add to `consumer`.

=== The _forEach_ method

If `accept` were not an abstract method, we'd have to obey the definitions of the previous chapters, and reason:

1. Because `accept` is `@Modified`, we mark the parameter `consumer` as `@Modified`.
2. Because `t`, the parameter of `accept`, is `@Modified`, we have to mark `forEach` as `@Modified`.

The result of the first reasoning would violate the `@Container` property on `Circular`, and we'd be very reluctant to do that.
The second one would make `forEach` structurally modifying, which again goes against our intuition.

Luckily, there are a number of observations that come to the rescue:

. Because the implementation comes 'from the outside', the only modifications that should really concern us here in `Circular` is the modifications to `accept` 's parameter `t`.
Other modifications are, for example, to the fields of the type in which the implementation is present, and they are far outside our scope.
. Because `accept` is abstract, we can have both non-modifying, and modifying implementations.
. Modifications to `t` propagate to the fields of `Circular`, `x` and `y`, so they would have an impact on the modification status of `forEach`.
. However, this impact is limited because `x` and `y` are of implicitly immutable type: external modifications to data of implicitly immutable type are outside our scope.

The last point allows us to keep `forEach` non-modifying.
The first and second point allow us to argue that calling `accept` here is not necessarily a modifying operation to `consumer`: it'll depend on the concrete implementation.
Here, we have no knowledge of the presence of fields in the implementation that can potentially be modified.
The third point, finally, gives us an incentive to mark the fact that our fields have been passed on to a potentially modifying abstract method within the parameter `consumer`.
This information will come in useful later; we will use the {propagateModification} annotation for this purpose.

This results in the following annotations for `forEach` in `Circular`:

.The _forEach_ method in _Circular_, annotated
[source,java]
----
@NotModified
public void forEach(@NotModified @PropagateModification Consumer<T> consumer) {
    consumer.accept(x);
    consumer.accept(y);
}
----

Looking at the more general case of a `forEach` implementation iterating over a list or array,

.Generic _forEach_ implementation
[source,java]
----
@NotModified
public void forEach(@NotModified @PropagateModification Consumer<T> consumer) {
    for(T t: list) consumer.accept(t);
}
----

we state that the four observations above still hold: implicitly immutable content inside the `list` is potentially modified by an implementation of `consumer`.
Or stated differently, modifications to the parameter of the concrete implementation are propagated into the implicitly immutable content of `list`.

=== Propagating modifications

Let us apply the `forEach` method to `StringBuilder`.
Note that a modification annotation on a parameter detects any modification to any field in the object graph of the parameter.

.Propagating the modification of _forEach_
[source,java]
----
static void print(@NotModified Circular<StringBuilder> c) {
    c.forEach(System.out::println); // <1>
}

static void addNewLine(@Modified Circular<StringBuilder> c) {
    c.forEach(sb -> sb.append("\n")); // <2>
}

static void replace(@Modified Circular<StringBuilder> c) {
    c.forEach(sb -> c.add(new StringBuilder("x" + sb))); // <3>
}

List<String> strings = ...
@Modified // <4>
void addToStrings(@NotModified Circular<StringBuilder> c) {
    c.forEach(sb -> strings.add(sb.toString()));
}
----
<1> Non-modifying method implies no modification on the implicitly immutable content of `c`.
<2> Parameter-modifying lambda propagates modification to `c` 's implicitly immutable content.
<3> Object-modifying lambda changing `c` but not its content (the string builder it holds).
<4> Example of modification to fields outside the scope of `Circular`.

It is item 2, `addNewLine`, that is of importance here.
Thanks to the {propagateModification} annotation, we know of a modification to `c`.

Without storing additional information (e.g., using an annotation like `@Modified1` on `c` in `addNewLine`), however, we cannot make the distinction between a modification to the string builders inside `x` and `y`, or an assignment to `x` or `y` in `Circular`, as in item 3.
In other words, we cannot determine {m} on the parameters of `useAddNewLine` in the following example:

.Using print and addNewLine
[source,java]
----
static String usePrint(@NotModified StringBuilder sb1,
                       @NotModified StringBuilder sb2,
                       @NotModified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1); // <1>
    circular.add(sb2);
    circular.add(sb3);
    print(circular);
    return circular.stream().collect(Collectors.joining());
}

static String useAddNewLine(@Modified StringBuilder sb1, //<2>
                            @Modified StringBuilder sb2,
                            @Modified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1);
    circular.add(sb2);
    circular.add(sb3);
    addNewLine(circular); // <3>
    return circular.stream().collect(Collectors.joining());
}
----
<1> `circular` now holds `sb1`
<2> impossible to determine
<3> The {modified} on `addNewLine` implies that `circular` has been modified, but we do not know if any of `sb1`, `sb2`, `sb3` has been affected.

[#content-linking]
=== Content linking

Going back to `Circular`, we see that the `add` method binds the parameter `t` to the instance by means of assignment.
Let us call this binding of parameters of implicitly immutable types _content linking_, and mark it using {dependent1}, _content dependence_:

.Extra annotation on add
[source,java]
----
@Modified
public void add(@Dependent1 T t) {
    if (next) {
        this.y = t;
    } else {
        this.x = t;
    }
    next = !next;
}
----

Note that content dependence implies normal independence, exactly because we are dealing with parameters of implicitly immutable type.
Thanks to this annotation, the statement `circular.add(sb1)` can content link `sb1` to circular.
When propagating the modification of `addNewLine`'s parameter, all variables content linked to the argument get marked.

A second way, next to assignment, of adding to content links is Java's for-each loop:

.For-each loop and content linking
[source,java]
----
Collection<StringBuilder> builders = ...;
for(StringBuilder sb: builders) { circular.add(sb); }
----

The local loop variable `sb` gets content linked to `circular`.
Crucially, however, it is not difficult to see that `sb` is also content linked to `builders`!
The `Collection` API will contain an `add` method annotated as:

[source,java]
----
@Modified
boolean add(@NotNull @Dependent1 E e) { return true; }
----

indicating that after calling `add`, the argument will become part of the implicitly immutable content of the collection.
We need yet another annotation, {dependent2}, to indicate that the implicitly immutable content of two objects are linked.
Looking at a possible implementation of `addAll`:

.addAll
[source,java]
----
@Modified
boolean addAll(@NotNull1 @Dependent2 Collection<? extends E> collection) {
    boolean modified = false;
    for (E e : c) if (add(e)) modified = true;
    return modified;
}
----

The call to `add` content links `e` to `this`.
Because `e` is also content linked to `c`, the parameter `collection`
holds implicitly immutable content linked to the implicitly immutable content of the instance.

Again, note that {dependent2} implies independence, because it deals with the implicitly immutable content.

We're now properly armed to see how a for-each loop can be defined as an iterator whose implicitly immutable content links to that of a container.

=== Iterator, Iterable, loops

Let us start with the simplest definition of an iterator, without `remove` method:

.Iterator, without remove
[source,java]
----
interface Iterator<T> {

    @Modified
    @Dependent1
    T next();

    @Modified
    boolean hasNext();
}
----

Either the `next` method, or the `hasNext` method, must make a change to the iterator, because it has to keep track of the next element.
As such, we make both {modified}.
Following the discussion in the previous section, `next` is {dependent1}, because it returns part of the implicitly immutable content held by the iterator.

The interface `Iterable` is a supplier of iterators:

.Iterable
[source,java]
----
interface Iterable<T> {

    @NotModified
    @Dependent2
    Iterator<T> iterator();
}
----

First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a sub-type, static or not, of the type implementing `Iterable`.
Secondly, the iterator itself is independent of the fields of the implementing type, but has the ability to return its implicitly immutable content.

The loop, on a variable `list` of type implementing `Iterable<T>`,

[source,java]
----
for(T t: list) { ... }
----

can be interpreted as

[source,java]
----
Iterator<T> iterator = list.iterator();
while(it.hasNext()) {
    T t = it.next();
    ...
}
----

The iterator is {dependent2}.
Via the `next` method, it content-links the implicitly immutable content of the `list` to `t`.

=== Independence of types

A concrete implementation of an iterator is a sub-type, static or not, of the iterable type:

[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {

    @NotNull1
    private final T[] elements;

    @SuppressWarnings("unchecked")
    public ImmutableArray(List<T> input) {
        this.elements = (T[]) input.toArray();
    }

    @Override
    @Independent
    public Iterator<T> iterator() {
        return new IteratorImpl();
    }

    @Container
    @Independent
    class IteratorImpl implements Iterator<T> {
        private int i;

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

For `ImmutableArray` to be level 2 immutable, the `iterator()` method must be independent of the field `elements`.
How do we know this?
The implementation type `IteratorImpl` cannot be level 2 immutable, because it needs to hold the state of the iterator.
However, it should protect the fields of its enclosing type.
We propose to add a definition for the independence of a type, very similar to the one enforced for level 2 immutability:

****
*Definition*: A type is *independent* when it follows these three rules:

*Rule 1*: All constructor parameters linked to fields, and therefore all fields linked to constructor parameters, must be {nm};

*Rule 2*: All fields linked to constructor parameters must be either private or level 2 immutable;

*Rule 3*: All return values of methods must be independent of the fields linked to constructor parameters.
****

The static variant of `IteratorImpl` makes rules 1 and 2 more obvious:

.Static iterator implementation
[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {
    ...

    @Container
    @Independent
    static class IteratorImpl implements Iterator<T> {
        private int i;
        private final T[] elements;

        private IteratorImpl(T[] elements) {
            this.elements = elements;
        }

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

=== More on implicitly immutable types

Looking at the <<support-lazy>> example, which immutability properties should we give the field `Supplier<T> supplier`?
The type `T` is implicitly immutable in `Lazy`, as it can be replaced by `java.lang.Object`.

We propose to add abstract types, where _only_ the abstract method is called, to the set of implicitly immutable types of the enclosing type.
The reasoning is that whilst you can access the type, you still cannot know the effect of this action.

