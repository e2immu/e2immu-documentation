[#higher-level-modifications]
== Abstract methods and higher-level modifications

[#hidden-immutable-content]
=== Hidden immutable content

From the point of view of the definition of level 2 immutability, fields are either already level 2 immutable, or they are mutable (modifiable) and the rules have to ensure that the modifications cannot take place.

Inside the group of fields of level 2 immutable types, we can make another distinction: between those types whose content is accessible, and those whose content is invisible because they are only represented by a (typically very) shallow interface which is level 2 immutable.
In the case of unbound parameter types, we chose to represent them in the type by `java.lang.Object`, or an empty interface which is very shallow indeed.

Let's go back to the simplest definition of a `Pair`,

[source,java]
----
@E2Container
public class Pair<K, V> {
    public final K k;
    public final V v;
    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Think of `K` and `V` as empty interfaces, which hide away all data held by any concrete instance.

On the opposite end of the spectrum we find

[source,java]
----
@E2Container
public record Coordinate(int x, int y, int z) {}
----

where all data is readily accessible, and, because of the finality of the class, no extensions can ever be made to add more (hidden, when presented with `Coordinate`) data.

In this continuum, we have to draw a line, and state that

****
Fields of abstract level 2 immutable types belong to the _hidden immutable content_ of the type.
Fields of unbound parameter types, potentially represented by an empty interface, belong to this category.
****

The term _hidden immutable_ stems from the fact that inside the type, immutability is mostly obtained by inaccessibility: it cannot be modified because it cannot even be reached.
The more data that is inaccessible to a given type, the further this type is away from being _deeply immutable_, yet still being level 2 immutable.
One could say that, recursively,

****
level 2 immutable type's content = accessible immutable content + hidden immutable content
****

As stated earlier, the base of the recursion is `java.lang.Object`, and in practice also the primitive types and some essential level 2 immutable types like `java.lang.String`.
Container types from the Collections framework like `java.util.List` provide the support data to build larger, more meaningful level 2 immutable types.

Note that, outside the type, the hidden immutable content need not be hidden nor immutable at all:

[source,java]
----
Pair<StringBuilder, Integer> twoBuilders = new Pair<>(new StringBuilder("x"), 1);
twoBuilders.k.append("!");
----

In the rest of this chapter, we will attempt to catch some modifications made by concrete implementations of abstract methods.
The machinery provided in the earlier chapters will be shown to be insufficient.
Please note that characterising _all_ modifications is a hopelessly complex, and unnecessary, task.
We will, however, need to deal with what can be seen as the first level of higher level modifications, if we want to be able to characterise the modifications going on in extremely important constructs such as iterators.

=== Setting the scene

The basis of this section is an example container class called `Circular`:

.First methods of Circular
[source,java]
----
@Container
class Circular<T> {

    private T x;
    private T y;
    private boolean next;

    public Circular() {
    }

    @Independent
    public Circular(Circular<T> c) {
        x = c.x;
        y = c.y;
        next = c.next;
    }

    @Modified
    public void add(T t) {
        if (next) {
            this.y = t;
        } else {
            this.x = t;
        }
        next = !next;
    }

    @NotModified
    @E2Container
    public Stream<T> stream() {
        return Stream.of(x, y);
    }
}
----

The `Circular` class is an extremely simple collection; it acts as a stand-in for many JDK collections like `java.util.List` or `java.util.Set`.
We also make use of the `Consumer` functional interface:

.Consumer
[source,java]
----
@FunctionalInterface
interface Consumer<T> {
    @Modified
    void accept(T t);
}
----

Note that the parameter `t` is implicitly marked {modified}.
As detailed in the first section on <<abstract-methods>>, the default modification status for abstract methods is {nm}.
we have to be explicit about `accept`, because requiring all implementations to be non-modifying would be overly restrictive.

Using the `Consumer` interface we introduce a `forEach` method in `Circular` which iterates over the two elements:

.A _forEach_ method in _Circular_
[source,java]
----
public void forEach(Consumer<T> consumer) {
    consumer.accept(x);
    consumer.accept(y);
}
----

Now we need to do some careful reasoning to determine the modification status of `forEach`, and to find out which annotation to add to `consumer`.

=== The _forEach_ method

Following the normal definitions of modification, we reason:

1. Because `accept` is `@Modified`, we mark the parameter `consumer` as `@Modified`.
2. Because `t`, the parameter of `accept`, is `@Modified`, we have to mark `forEach` as `@Modified`.

The result of the first statement would violate the `@Container` property on `Circular`, and we'd be very reluctant to do that.
The second one would make `forEach` modifying in `Circular`, which again goes against our intuition: looping in itself is not modifying.

Luckily, there are a number of observations that come to the rescue.

First, because the implementation comes 'from the outside' (is external to `Circular`), the only modifications that should really concern us in a `forEach` method are the modifications to `accept` 's parameter `t`.
Other modifications are, for example, to the fields of the type in which the implementation is present, and we believe them to be outside our scope.
However, if we replace `Consumer` with `Set` and `accept` with `add`, we encounter a modification that we do not really want to ignore, in an otherwise equal setting.
Therefore, we will have to revert to a contracted {ignoreModifications} annotation on the parameter `consumer`, if we want to avoid `Circular` losing the `@Container` property.

The second modification, however, is one we can ignore in the `Circular` type, and _defer_ or propagate to the place where a concrete implementation of the consumer is presented.
We can ignore it here, because `x` and `y` are fields of hidden immutable type; what happens to their content happens outside the primary type, outside our zone of control.
(Note that if they were parameters, this would not hold: recall from the section on <<modification>> that the rules for modification on parameters refer to any change in the parameter's object graph.) The fact that hidden immutable content is passed on as an argument to a method of `consumer` will be reflected by a {dependent1} annotation.
It will take care of the propagation of modifications from the concrete implementation into the hidden immutable content.

This results in the following annotations for `forEach` in `Circular`:

.The _forEach_ method in _Circular_, annotated
[source,java]
----
@NotModified
public void forEach(@IgnoreModifications @Dependent1 Consumer<T> consumer) {
    consumer.accept(x);
    consumer.accept(y);
}
----

Note that we assume that we'll need {ignoreModifications} for almost every use of a functional interface from `java.util.function` occurring as a parameter.
These types are for generic use; one should use them to represent some specific data type where modifications are of concern to the current type.
Therefore, we make this annotation implicit in exactly this context.

Looking at the more general case of a `forEach` implementation iterating over a list or array, we therefore end up with:

.Generic _forEach_ implementation
[source,java]
----
@NotModified
public void forEach(@Dependent1 Consumer<T> consumer) {
    for(T t: list) consumer.accept(t);
}
----

Modifications to the parameter, made by the concrete implementation, are propagated into the hidden immutable content of `list`, as described in the next section.

=== Propagating modifications

Let us apply the `forEach` method to `StringBuilder`.

.Propagating the modification of _forEach_
[source,java]
----
static void print(@NotModified Circular<StringBuilder> c) {
    c.forEach(System.out::println); // <1>
}

static void addNewLine(@Modified Circular<StringBuilder> c) {
    c.forEach(sb -> sb.append("\n")); // <2>
}

static void replace(@Modified Circular<StringBuilder> c) {
    c.forEach(sb -> c.add(new StringBuilder("x" + sb))); // <3>
}

List<String> strings = ...
@Modified // <4>
void addToStrings(@NotModified Circular<StringBuilder> c) {
    c.forEach(sb -> strings.add(sb.toString()));
}
----
<1> Non-modifying method implies no modification on the hidden immutable content of `c`.
<2> Parameter-modifying lambda propagates modification to `c` 's hidden immutable content.
<3> Object-modifying lambda changing `c` but not its content (the string builder it holds).
<4> Example of modification to fields outside the scope of `Circular`.

It is item 2, `addNewLine`, that is of importance here.
Thanks to the {dependent1} annotation, we know of a modification to `c`.
It helps to see the for-loop written out, if we temporarily assume that we have added an implementation of `Iterable` to `Circular`:

[source,java]
----
static void addNewLine(@Modified Circular<StringBuilder> c) {
    for(StringBuilder sb: c) {
      sb.append("\n"));
    }
}
----

We really need the link between `sb` and `c` for the modification on `sb` to propagate to `c`.

Without storing additional information (e.g., using an as yet undefined annotation like `@Modified1` on `c` in `addNewLine`), however, we cannot make the distinction between a modification to the string builders inside `x` and `y`, or an assignment to `x` or `y` in `Circular`, as in item 3.
In other words, we cannot determine {m} on the parameters of `useAddNewLine` in the following example:

.Using print and addNewLine
[source,java]
----
static String usePrint(@NotModified StringBuilder sb1,
                       @NotModified StringBuilder sb2,
                       @NotModified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1); // <1>
    circular.add(sb2);
    circular.add(sb3);
    print(circular);
    return circular.stream().collect(Collectors.joining());
}

static String useAddNewLine(@Modified StringBuilder sb1, //<2>
                            @Modified StringBuilder sb2,
                            @Modified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1);
    circular.add(sb2);
    circular.add(sb3);
    addNewLine(circular); // <3>
    return circular.stream().collect(Collectors.joining());
}
----
<1> `circular` now holds `sb1`
<2> impossible to determine
<3> The {modified} on `addNewLine` implies that `circular` has been modified, but we do not know if any of `sb1`, `sb2`, `sb3` has been affected.

[#content-linking]
=== Content linking

Going back to `Circular`, we see that the `add` method binds the parameter `t` to the instance by means of assignment.
Let us call this binding of parameters of hidden immutable types _content linking_, and mark it using {dependent1}, _content dependence_:

.Extra annotation on add
[source,java]
----
@Modified
public void add(@Dependent1 T t) {
    if (next) {
        this.y = t;
    } else {
        this.x = t;
    }
    next = !next;
}
----

Note that content dependence implies normal independence, exactly because we are dealing with parameters of hidden immutable type.
Thanks to this annotation, the statement `circular.add(sb1)` can content link `sb1` to circular.
When propagating the modification of `addNewLine` 's parameter, all variables content linked to the argument get marked.

A second way, next to assignment, of adding to content links is Java's for-each loop:

.For-each loop and content linking
[source,java]
----
Collection<StringBuilder> builders = ...;
for(StringBuilder sb: builders) { circular.add(sb); }
----

The local loop variable `sb` gets content linked to `circular`.
Crucially, however, it is not difficult to see that `sb` is also content linked to `builders`!
The `Collection` API will contain an `add` method annotated as:

[source,java]
----
@Modified
boolean add(@NotNull @Dependent1 E e) { return true; }
----

indicating that after calling `add`, the argument will become part of the hidden immutable content of the collection.
We reuse the annotation {dependent1} to indicate that the hidden immutable content of two objects are linked.
Looking at a possible implementation of `addAll`:

.addAll
[source,java]
----
@Modified
boolean addAll(@NotNull1 @Dependent1 Collection<? extends E> collection) {
    boolean modified = false;
    for (E e : c) if (add(e)) modified = true;
    return modified;
}
----

The call to `add` content links `e` to `this`.
Because `e` is also content linked to `c`, the parameter `collection`
holds hidden immutable content linked to the hidden immutable content of the instance.

Again, note that {dependent1} implies independence, because it deals with the hidden immutable content.

We're now properly armed to see how a for-each loop can be defined as an iterator whose hidden immutable content links to that of a container.

=== Iterator, Iterable, loops

Let us start with the simplest definition of an iterator, without `remove` method:

.Iterator, without remove
[source,java]
----
interface Iterator<T> {

    @Modified
    @Dependent1
    T next();

    @Modified
    boolean hasNext();
}
----

Either the `next` method, or the `hasNext` method, must make a change to the iterator, because it has to keep track of the next element.
As such, we make both {modified}.
Following the discussion in the previous section, `next` is {dependent1}, because it returns part of the hidden immutable content held by the iterator.

The interface `Iterable` is a supplier of iterators:

.Iterable
[source,java]
----
interface Iterable<T> {

    @NotModified
    @Dependent1
    Iterator<T> iterator();
}
----

First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a sub-type, static or not, of the type implementing `Iterable`.
Secondly, the iterator itself is independent of the fields of the implementing type, but has the ability to return its hidden immutable content.

The loop, on a variable `list` of type implementing `Iterable<T>`,

[source,java]
----
for(T t: list) { ... }
----

can be interpreted as

[source,java]
----
Iterator<T> iterator = list.iterator();
while(it.hasNext()) {
    T t = it.next();
    ...
}
----

The iterator is {dependent1}.
Via the `next` method, it content-links the hidden immutable content of the `list` to `t`.

=== Independence of types

A concrete implementation of an iterator is a sub-type, static or not, of the iterable type:

[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {

    @NotNull1
    private final T[] elements;

    @SuppressWarnings("unchecked")
    public ImmutableArray(List<T> input) {
        this.elements = (T[]) input.toArray();
    }

    @Override
    @Independent
    public Iterator<T> iterator() {
        return new IteratorImpl();
    }

    @Container
    @Independent
    class IteratorImpl implements Iterator<T> {
        private int i;

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

For `ImmutableArray` to be level 2 immutable, the `iterator()` method must be independent of the field `elements`.
How do we know this?
The implementation type `IteratorImpl` cannot be level 2 immutable, because it needs to hold the state of the iterator.
However, it should protect the fields of its enclosing type.
We propose to add a definition for the independence of a type, very similar to the one enforced for level 2 immutability:

****
*Definition*: A type is *independent* when it follows these three rules:

*Rule 1*: All constructor parameters linked to fields, and therefore all fields linked to constructor parameters, must be {nm};

*Rule 2*: All fields linked to constructor parameters must be either private or level 2 immutable;

*Rule 3*: All return values of methods must be independent of the fields linked to constructor parameters.
****

The static variant of `IteratorImpl` makes rules 1 and 2 more obvious:

.Static iterator implementation
[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {
    ...

    @Container
    @Independent
    static class IteratorImpl implements Iterator<T> {
        private int i;
        private final T[] elements;

        private IteratorImpl(T[] elements) {
            this.elements = elements;
        }

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

