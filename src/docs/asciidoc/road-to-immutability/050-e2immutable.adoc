== Level 2 immutability

=== Definition and examples

First, what do we want intuitively?
A useful form of immutability, less strong than deeply immutable, but better than level 1 immutability for many situations.
We propose the following description:

****
After construction, an immutable type holds a number of objects; the type will not change their content, nor will it exchange these objects for other objects, or allow others to do so.
The type is not responsible for what others do to the content of the objects it was given.
****

Technically, level 2 immutability is much harder to define than level 1 immutability.
We identify three rules, on top of the obvious level 1 immutability requirement.
The first one prevents the type from making changes to its own fields:

****
*Definition*: the *first rule of level 2 immutability* is that all fields must be {nm}.
****

Our friend the `Pair` satisfies this first rule:

.Example {counter:example}, the class `Pair`, revisited [[type-pair]]
[source,java]
----
public class Pair<K,V> {
    public final K k;
    public final V v;

    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Note that since `K` and `V` are unbound generic types, it is not even possible to modify their content from inside `Pair`, since there are no modifying methods one can call on unbound types.

How does it fit the intuitive rule for immutability?
The type `Pair` holds two objects.
The type does not change their content, nor will it exchange these two objects for others, or allow others to do so.
It is clear the users of `Pair` may be able to change the content of the objects they put in the `Pair`.
Summarizing: `Pair` fits the intuitive definition nicely.

Here is an example which shows the necessity of the first rule more explicitly:

.Example {counter:example}: the types `Point` and `Line`
[#point-and-line]
[source,java]
----
@Container
class Point {
    @Variable
    private double x;

    @Variable
    private double y;

    @NotModified
    public double getX() {
        return x;
    }

    @Modified
    public void setX(double x) {
        this.x = x;
    }

    @NotModified
    public double getY() {
        return y;
    }

    @Modified
    public void setY(double y) {
        this.y = y;
    }
}

@E1Container
class Line {
    @Final
    @Modified
    private Point point1;

    @Final
    @Modified
    private Point point2;

    public Line(Point point1, Point point2) {
        this.point1 = point1;
        this.point2 = point2;
    }

    @NotModified
    public Point middle() {
        return new Point((point1.getX() + point2.getX())/2.0,
             (point1.getY()+point2.getY())/2.0);
    }

    @Modified
    public void translateHorizontally(double x) {
        point1.setX(point1.getX() + x); // <1>
        point2.setX(point2.getX() + x);
    }
}
----

<1> Modifying operation on `point1`.

The fields `point1` and `point2` are effectively final.
Without the translation method, the fields would be {nm} as well.
The translation method modifies the fields' content, preventing the type from becoming level 2 immutable.

From the restriction of rule 1, that all its fields should remain unmodified, it follows that, excluding external changes, every method call on a level 2 immutable container object with the same arguments will render the same result.
We note that this statement cannot be bypassed by using _static_ state, i.e., state specific to the type rather than the object.
The definitions make no distinction between static and instance fields.

To obtain a useful definition of immutability, one which is not too strict yet follows our intuitive requirements, we should allow modifiable fields, if they are properly shielded from the modifications they intrinsically allow.
We will introduce two additional rules to constrain the modifications of this modifiable data.
Together with the first rule, and building on level 1 immutability, we define:

****
*Definition: level 2 immutability*:

(*Rule 0*: The type is level 1 immutable: all fields are effectively final)

*Rule 1*: All fields are {nm}.

*Rule 2*: All fields are either private, or of level 2 immutable type.

*Rule 3*: All constructors and non-private methods are independent of the modifiable fields.
****

Rule 2 is there to ensure that the modifiable fields of the object cannot be modified by means of access to the non-private fields.
Rule 3 ensures that the modifiable fields of the object cannot be modified externally by obtaining references to the fields via a parameter or return value.

Note that:

* We state that all primitive types are level 2 immutable, as is `java.lang.Object`.
Whilst this is fairly obvious in the case of primitives, level 2 immutability for `Object` requires us to either ignore the methods related to synchronization, or to assume that its implementation (for it is not an abstract type) has no fields.
* A consequence of rule 1 is that all methods in a level 2 immutable type must be {nm}.
* A field whose type is an unbound type parameter, is of level 2 immutable type, as this type parameter could be substituted by `java.lang.Object`, which we have just declared to be level 2 immutable.
More details can be found in the section on <<generics>>.
* Constructor parameters of unbound type parameter, or method return types of unbound type parameter do not have to follow rule 3 (or equivalently, they are always independent, in the same way that level 2 immutable types are): inside the class, there is no way of modifying them.
This will be expanded on in <<immutable-content>>.
* The section on <<inheritance>> will show how the immutability property relates to implementing interfaces, and sub-classing.
This is important because the definition is recursive, with `java.lang.Object` the level 2 immutable base of the recursion.
All other types must extend from it.
* The section on <<abstract-methods>> will detail how level 2 immutability is computed for abstract types (interfaces, abstract classes).
* The first rule can be reached _eventually_ if there is one or more methods that effect a transition from the mutable to the immutable state.
This typically means that all methods that assign or modify fields become off-limits after calling this marker method.
Eventuality for rules 2 and 3 seems too far-fetched.
We address the topic of eventual immutability fully in the section <<eventual-immutability>>.

Let us go to examples immediately.

.Example {counter:example}, explaining level 2 immutability: with array, version 1, not good
[source,java]
----
@E1Container
class ArrayContainer1<T> {
    @NotModified
    private final T[] data;

    @Dependent
    public ArrayContainer1(T[] ts) {
        this.data = ts;
    }

    @NotModified
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

After creation, external changes to the source array `ts` are effectively modifications to the field `data`.
This construct fails rule 3, independence.
The field is a modifiable data structure, and must be shielded from external modifications.

.Example {counter:example}, explaining level 2 immutability: with array, version 2, not good
[source,java]
----
@E1Container
class ArrayContainer2<T> {
    @NotModified
    public final T[] data;

    public ArrayContainer2(T[] ts) {
        this.data = new T[ts.length];
        System.arraycopy(ts, 0, data, 0, ts.length);
    }

    @NotModified
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

Users of this type can modify the content of the array using direct field access!
This construct fails rule 2, which applies for the same reasons as in the previous example.

.Example {counter:example}, explaining level 2 immutability: with array, version 3, safe
[source,java]
----
@E2Container
class ArrayContainer3<T> {
    @NotModified
    private final T[] data; // <1>

    public ArrayContainer3(T[] ts) {
        this.data = new T[ts.length]; // <2>
        System.arraycopy(ts, 0, data, 0, ts.length);
    }

    @NotModified
    public Stream<T> stream() {
        return Arrays.stream(data);
    }
}
----

<1> The array is private, and therefore protected from external modification via the direct access route.
<2> The array has been copied, and therefore is independent of the one passed in the parameter.

The independence rule enforces the type to have its own modifiable structure, rather than someone else's.
Here is the same group of examples, now with JDK Collections:

.Example {counter:example}, explaining level 2 immutability: with collection, version 1, not good
[source,java]
----
@E1Container
class SetBasedContainer1<T> {
    @NotModified
    private final Set<T> data;

    @Dependent
    public SetBasedContainer1(Set<T> ts) {
        this.data = ts; // <1>
    }

    @NotModified
    public Stream<T> stream() {
        return data.stream();
    }
}
----

<1> After creation, changes to the source set are effectively changes to the data.

The lack of independence of the constructor violates rule 3 in the first example.

.Example {counter:example}, explaining level 2 immutability: with collection, version 2, not good
[source,java]
----
@E1Container
class SetBasedContainer2<T> {
    @NotModified
    public final Set<T> data; // <1>

    @Independent
    public SetBasedContainer2(Set<T> ts) {
        this.data = new HashSet<>(ts);
    }

    @NotModified
    public Stream<T> stream() {
        return data.stream();
    }
}
----

<1> Users of this type can modify the content of the set after creation!

Here, the `data` field is public, which allows for external modification.

.Example {counter:example}, explaining level 2 immutability: with collection, version 3, safe
[source,java]
----
@E2Container
class SetBasedContainer3<T> {
    @NotModified
    private final Set<T> data; // <1>

    public SetBasedContainer3(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }

    public Stream<T> stream() {
        return data.stream();
    }
}
----

<1> The set is private, and therefore protected from external modification.
<2> The set has been copied, and therefore is independent of the one passed in the parameter.

Finally, we have a level 2 immutable type.

.Example {counter:example}, explaining level 2 immutability: with collection, version 4, safe
[source,java]
----
@E2Container
class SetBasedContainer4<T> {
    @E2Container
    public final Set<T> data; // <1>

    public SetBasedContainer4(Set<T> ts) {
        this.data = Set.copyOf(ts); // <2>
    }

    public Stream<T> stream() {
        return data.stream();
    }
}
----

<1> the data is public, but the `Set` is {e2immutable} itself, because its content is the result of `Set.copyOf`.
<2> Independence guaranteed.

The section on <<dynamic-type-annotations>> will explain how the {e2container} annotation travels to the field `data`.

The independence rule, rule 3, is there to ensure that the type does not expose its modifiable data through parameters and return types:

.Example {counter:example}, explaining level 2 immutability: with collection, version 5, not good
[source,java]
----
@E1Container
class SetBasedContainer5<T> {
    @NotModified
    private final Set<T> data; // <1>

    @Independent
    public SetBasedContainer5(Set<T> ts) {
        this.data = new HashSet<>(ts); // <2>
    }

    @Dependent
    public Set<T> getSet() {
        return data; // <3>
    }
}
----

<1> No exposure via the field
<2> No exposure via the parameter of the constructor
<3> ... but exposure via the getter.
The presence of the getter is equivalent to adding the modifiers `public final` to the field.

Note that by decomposing rules 0 and 1, we observe that requiring all fields to be {final} and {nm} is equivalent to requiring that all non-private fields have the `final` modifier, and that methods that are not part of the construction phase, are {nm}.
The final example shows a type which violates this rule 1, because a modifying method has been added:

.Example {counter:example}, explaining level 2 immutability: with collection, version 6, not good
[source,java]
----
@E1Container
class SetBasedContainer6<T> {
    @Modified
    public final Set<T> set = new HashSet<>();

    @Modified
    public void add(T t) { set.add(t); }

    @NotModified
    public Stream<T> stream() { return set.stream(); }
}
----

[#inheritance]
=== Inheritance

Deriving from a class that is level 2 immutable, is the most normal situation: since `java.lang.Object` is a level 2 immutable container, every class will do so.
Clearly, the property is not inherited.
Most importantly, the analyser prohibits changing the modification status of methods: once a method is non-modifying, it cannot become modifying in a derived class.
This means, for example, that the analyser will block a modifying `equals()` or `toString()` method, in any class.
Similarly, no implementation of `java.util.Collection.size()` will be allowed to be modifying.

The guiding principle here is that of _consistency of expectation_: software developers are expecting that `equals` is non-modifying.
They know that a setter will make an assignment, but they'll expect a getter to simply return a value.
No getter should ever be modifying.

The other direction is more interesting, while equally simple to explain: deriving from a parent class cannot increase the immutability level.
A method overriding one marked {modified} does not have to be modifying, but it is not allowed to be explicitly marked {nm}:

.Example {counter:example}, illegal modification status of methods
[source,java]
----
abstract class MyString implements Collection<String> {
    private String string = "";

    @Override
    public int size() {
        string = string + "!"; // <1>
        return string.length();
    }

    @Override
    @NotModified // <2>
    public abstract boolean add(String s);
}
----

<1> Not allowed!
Any implementation of `Collection.size()` must be non-modifying.
<2> Not allowed!
You cannot explicitly (contractually) change `Collection.add()` from {modified} to {nm} in a sub-type.

Following the same principles, we observe that types deriving from a {container} super-type need not be a container themselves.
So while we may state that `Collection` is a container, it is perfectly possible to implement a collection which has public methods which modify their parameters, _as long as the methods inherited from `Collection` do not modify their parameters_.
In other words, you can add new parameter-modifying methods, but you cannot change the modification status of `size`!

Note that sealed types (since JDK 17) reject the 'you can always extend' assumptions of Java types.
In this case, all sub-types are known, and visible.
The single practical consequence is that if the parent type is abstract, its annotations need not be contracted: they can be computed because all implementations are available to the analyser.

[#generics]
=== Generics

Type parameters are either _unbound_, in which case they can represent any type, or they explicitly extend a given type.
Because the unbound case is simply a way of saying that the type parameter extends `java.lang.Object`, we can say that all type parameters extend a certain type, say `T extends E`.

The analyser simply treats the parameterized type `T` as if it were the type `E`.
In the case of unbound parameter types and `java.lang.Object`, we find an {e2container} type.
The latter has no modifying methods, which implies that rules 2 and 3 of level 2 immutability are automatically satisfied for fields of unbound parameter type.

The analyser recognises types that can be replaced by an unbound parameter type, when they are used _transparently_: no methods are called on it, save the ones from `java.lang.Object`; none of its fields are accessed, and it is not used as an argument to parameters where anything more specific than `java.lang.Object` is required.
It will issue a warning, and internally treat the type as an unbound parameter type, and hence {e2container}, even if the type is obviously modifiable.

The following trivial example should clarify:

.Example {counter:example}, a type _transparent_ in a class
[source,java]
----
@E2Container
public class OddPair {

    private final Set<String> set;
    private final StringBuilder sb;

    public OddPair(Set<String> set, StringBuilder sb) {
        this.set = set;
        this.sb = sb;
    }

    public Set<String> getSet() { return set; }
    public StringBuilder getSb() { return sb; }
}
----

Nowhere in `OddPair` do we make actual use of the fact that `set` is of type `Set`, or `sb` is of type `StringBuilder`.
The analyser encourages you to replace `Set` by some unbound parameter type, say `K`, and `StringBuilder` by some other, say `V`.
The result is, of course, the type `Pair` as defined <<type-pair,earlier>>.

[#abstract-methods]
=== Abstract methods

Because `java.lang.Object` is a level 2 immutable container, trivial extensions are, too:

.Example {counter:example}, trivial extensions of `java.lang.Object`
[source,java]
----
@E2Container
interface Marker { }

@E2Container
class EmptyClass { }

@E2Container
class ImplementsMarker implements Marker { }

@E2Container
class ExtendsEmptyClass extends ImplementsMarker { }
----

Things only become interesting when methods enter the picture.
Annotation-wise, we stipulate that

IMPORTANT: Unless otherwise explicitly annotated, we will assume that abstract methods, be they in interfaces or abstract classes, are {nm}.

Furthermore, we will also impose special variants of the rules for level 2 immutability of an abstract type `T`, to be obeyed by the abstract methods:

****
*Variant of rule 1*: Abstract methods must be non-modifying.

*Variant of rule 3*: Abstract methods returning values must be {independent}, i.e., the object they return must be independent of the fields.
They cannot expose the fields via parameters: parameters of non-primitive, non-level 2 immutable type must be {independent}.
****

The consequence of these choices is that implementations and extensions of abstract and non-abstract types will have the opportunity to have the same immutability properties.
This allows us, e.g., to think of every implementation of `java.util.Set` as a level 1 immutable container, if we limit to the public methods of `Set`.
Similarly, we can treat any implementation of `Comparable`, defined as:

.Example {counter:example}, `java.lang.Comparable` annotated
[source,java]
----
@E2Container
interface Comparable<T> {

    // @NotModified implicitly present
    int compareTo(@NotModified T other);
}
----

as a level 2 immutable type when the only method we can access is `compareTo`.

As for as the modification status of the _parameters_ of abstract methods is concerned, we start off with {modified} rather than with {nm}:

IMPORTANT: Unless otherwise explicitly annotated, or their types are level 2 immutable, we will assume that the parameters of abstract methods, be they in interfaces or abstract classes, are {modified}.
Overriding the method, the contract can change from {modified} to {nm}, but not from {nm} to {modified}.

While it is possible to compute the immutability and container status of interface types, using the rules presented above, it often makes more practical sense to use the annotations as contracts: they may save a lot of annotation work on the abstract methods in the interface.
We repeat that no implementation of a level 2 immutable interface is guaranteed to be level 2 immutable itself; nor does this guarantee hold for the container property unless no new non-private methods have been added.

We continue this section with some examples which will form the backbone of the examples in <<immutable-content>>.

If semantically used correctly, types implementing the `HasSize` interface expose a single numeric aspect of their content:

.Example {counter:example}, the `HasSize` interface
[source,java]
----
@E2Container // computed (or contracted)
interface HasSize {

    // implicitly present: @NotModified
    int size();

    @NotModified // computed, not an abstract method!
    default boolean isEmpty() {
        return size() == 0;
    }
}
----

We extend to:

.Example {counter:example}, still level 2 immutable: `NonEmptyImmutableList`
[source,java]
----
@E2Container // computed, contracted
interface NonEmptyImmutableList<T> extends HasSize {

    // implicitly present: @NotModified
    @Independent // <1>
    T first();

    // implicitly present: @NotModified
    void visit(Consumer<T> consumer); // <2>

    @Constant // <3>
    @NotModified // <3>
    @Override
    default boolean isEmpty() {
        return false;
    }
}
----

<1> Whilst formally, `T` will always be {independent} (because it represents the level 2 immutable type `java.lang.Object`), contracting the {independent} annotation here will force all concrete implementations to have an independent `first` method.
If the concrete replacement for `T` is modifiable, the independence rule must be satisfied.
<2> The parameter `consumer` would normally be {modified}, which would break the {container} property that we wish for `NonEmptyImmutableList`.
However, as detailed and explained in <<immutable-content>>, the abstract types in `java.util.function` receive an implicit {ignoreModifications} annotation.
<3> Computed, because it is not an abstract method.

The `Consumer` interface is defined and annotated as:

.Example {counter:example}, the _java.util.function.Consumer` interface, annotated
[source,java]
----
@FunctionalInterface
interface Consumer<T> {

    @Modified
    void accept(T t); // @Modified on t implicit
}
----

Implementations of the `accept` method are allowed to be modifying (even though in `NonEmptyImmutableList.visit` we decide to ignore this modification!).
They are also allowed to modify their parameter, as we will demonstrate shortly.

Let's downgrade from {e2container} to {e1container} by adding a modifying method:

.Example {counter:example}, not level 2 immutable anymore: `NonEmptyList` [[NonEmptyList]]
[source,java]
----
@E1Container
interface NonEmptyList<T> extends NonEmptyImmutableList<T> {

    @Modified
    void setFirst(@NotModified T t);
}
----

The method `setFirst` goes against the default annotations twice: because it is modifying, and because it promises to keep its parameter unmodified.
Implementations can even lose level 1 immutability:

.Example {counter:example}, mutable implementation of `NonEmptyList`
[source,java]
----
@Container
static class One<T> implements NonEmptyList<T> {

    @Variable
    private T t;

    @NotModified
    @Override
    public T first() {
        return t;
    }

    @Modified
    @Override
    public void setFirst(T t) {
        this.t = t;
    }

    @Constant
    @NotModified
    @Override
    public int size() {
        return 1;
    }

    @NotModified
    @Override
    public void visit(Consumer<T> consumer) {
        consumer.accept(t);
    }
}
----

Here is a (slightly more convoluted) implementation that remains {e1container}:

.Example {counter:example}, level 1 immutable implementation of `NonEmptyList`
[source,java]
----
@E1Container
static class OneWithOne<T> implements NonEmptyList<T> {
    private final One<T> one = new One<>();

    @NotModified
    @Override
    public T first() {
        return one.first();
    }

    @Modified
    @Override
    public void setFirst(T t) {
        one.setFirst(t);
    }

    @Constant
    @NotModified
    @Override
    public int size() {
        return 1;
    }

    @NotModified
    @Override
    public void visit(Consumer<T> consumer) {
        consumer.accept(first());
    }
}
----

Obviously, a {e2container} implementation is not possible: the immutability status of an extension (`OneWithOne`, `One`) cannot be better than that of the type it is extending from (`NonEmptyList`).

We end the section by showing how concrete implementations of the `accept` method in `Consumer` can make modifications.
First, modifications to the parameter:

.Example {counter:example}, modification to the parameter of `Consumer.accept`
[source,java]
----
One<StringBuilder> one = new One<>();
one.setFirst(new StringBuilder());
one.visit(sb -> sb.append("!"));
----

The last statement is maybe more easily seen as:

.Example {counter:example}, modification to the parameter of `Consumer.accept`, written out
[source,java]
----
one.visit(new Consumer<StringBuilder> {

   @Override
   public void accept(StringBuilder sb) {
       sb.append("!");
   }
});
----

Second, modifications to the fields of the type:

.Example {counter:example}, the method `Consumer.accept` modifying a field
[source,java]
----
@E1Container
class ReceiveStrings implements Consumer<String> {

    @Modified
    public final List<String> list = new ArrayList<>();

    @Modified
    @Override
    public void accept(String string) {
        list.add(string);
    }
}
----

[#static-side-effects]
=== Static side effects

Up to now, we have made no distinction between static fields and instance fields: modifications are modifications.
Inside a primary type, we will stick to this rule.
In the following example, each call to `getK` increments a counter, which is a modifying operation because the type owns the counter:

.Example {counter:example}, modifications on static fields are modifications
[source,java]
----
@E1Container
public class CountAccess<K> {

    @NotModified
    private final K k;

    @Modified
    private static final AtomicInteger counter = new AtomicInteger();

    public CountAccess(K k) {
        this.k = k;
    }

    @Modified
    public K getK() {
        counter.getAndIncrement();
        return k;
    }

    @NotModified
    public static int countAccessToK() {
        return counter.get();
    }
}
----

We can explicitly ignore modifications with the {ignoreModifications} annotation, which may make sense from a semantic point of view:

.Example {counter:example}, modification on static field, explicitly ignored
[source,java]
----
@E2Container
public class CountAccess<K> {

    @NotModified
    private final K k;

    @IgnoreModifications
    private static final AtomicInteger counter = new AtomicInteger();

    public CountAccess(K k) {
        this.k = k;
    }

    @NotModified // <1>
    public K getK() {
        counter.getAndIncrement(); // <1>
        return k;
    }

    @NotModified
    public static int countAccessToK() {
        return counter.get();
    }
}
----

<1> The effects of the modifying method `getAndIncrement` are ignored.

Note that when the modification takes place inside the constructor, it is still not ignored, because for static fields, static code blocks act as the constructor:

.Example {counter:example}, modification of static field can occur inside constructor
[source,java]
----
@E1Container
public class HasUniqueIdentifier<K> {

    public final K k;
    public final int identifier;

    @Modified
    private static final AtomicInteger generator = new AtomicInteger();

    public HasUniqueIdentifier(K k) {
        this.k = k;
        identifier = generator.getAndIncrement();
    }
}
----

Only modifications in a static code block are ignored:

.Example {counter:example}, static code blocks are the constructors of static fields
[source,java]
----
public class CountAccess<K> {
    ...
    private static final AtomicInteger counter;

    static {
        counter = new AtomicInteger();
        counter.getAndIncrement(); // <1>
    }
    ...
}
----

<1> Modification, part of the construction process.

Nevertheless, we introduce the following rule which does distinguish between modifications on static and instance types:

****
When static modifying methods are called, on a field not belonging to the primary type or any of the parent types, or directly on a type expression which does not refer to any of the types in the primary type or parent types, we will make an exception to this rule, and classify the modification as a _static side effect_.
****

This is still consistent with the rules of level 2 immutable types, which only look at the fields and assume that when methods do not modify the fields, they are actually non-modifying.
Without an {ignoreModifications} annotation on the field `System.out` (which we would typically add), printing to the console results in

.Example {counter:example}, static side effects annotation
[source,java]
----
@StaticSideEffects
@NotModified
public K getK() {
    System.out.println("Getting "+k);
    return k;
}
----

We leave it up to the programmer or designer to determine whether static calls deserve a {sse} warning, or not.
In almost all instances, we prefer a singleton instance (see <<singleton-classes>>) over a class with modifying static methods.
In singletons the normal modification rules apply, unless {ignoreModifications} decorates the static field giving access to the singleton.

[#value-based-classes]
=== Value-based classes

Quoting from the JDK 8 documentation, value-based classes are

. final and immutable (though may contain references to mutable objects);
. have implementations of equals, hashCode, and toString which are computed solely from the instance's state and not from its identity or the state of any other object or variable;
. make no use of identity-sensitive operations such as reference equality (==) between instances, identity hash code of instances, or synchronization on an instances's intrinsic lock;
. are considered equal solely based on equals(), not based on reference equality (==);
. do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of returned instances;
. are freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior.

Item 1 requires level 1 immutability (all fields are {final}) but does not specify any of the restrictions we require for level 2 immutability.
Item 2 implies that should `equals`, `hashCode` or `toString` make a modification to the object, its state changes, which would then change the object with respect to other objects.
We could conclude that these three methods cannot be modifying.

Loosely speaking, objects of a value-based class can be identified by the values of their fields.
Level 2 immutability (or deeper) is not a requirement to be a value-based class.
However, we expect many level 2 immutable types will become value-classes.
Revisiting the example from the previous section, we can construct a counter-example:

.Example {counter:example}, level 2 immutable type which is not value-based
[source,java]
----
@E2Container
public class HasUniqueIdentifier<K> {
    public final K k;
    public final int identifier;

    @NotModified
    private static final AtomicInteger generator = new AtomicInteger();

    public HasUniqueIdentifier(K k) {
        this.k = k;
        identifier = generator.getAndIncrement();
    }

    @Override
    public boolean equals(Object other) {
        if(this == other) return true;
        if(other instanceof HasUniqueIdentifier<?> hasUniqueIdentifier) {
            return identifier == hasUniqueIdentifier.identifier;
        }
        return false;
    }
}
----

The `equals` method violates item 2 of the value-class definition, maybe not to the letter but at least in its spirit: the field `k` is arguably the most important field, and its value is not taken into account when computing equality.

[#dynamic-type-annotations]
=== Dynamic type annotations

When it is clear a method returns an immutable set, but the formal type is `java.util.Set`, the {e2immutable} annotation can 'travel':

.Example {counter:example}, revisiting `SetBasedContainer6`
[source,java]
----
@E2Container
class SetBasedContainer6<T> {
    @E2Container
    public final Set<T> data;

    public SetBasedContainer4(Set<T> ts) {
        this.data = Set.copyOf(ts);
    }

    @E2Container
    public Set<T> getSet() {
        return data;
    }
}
----

Whilst `Set` in general is not {e2immutable}, the `data` field itself is.

The computations that the analyser needs to track dynamic type annotations, are similar to those it needs to compute eventual immutability.
We introduce them in the next chapter.
