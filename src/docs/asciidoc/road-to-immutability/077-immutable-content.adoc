[#immutable-content]
== Immutable content

[#inaccessible-immutable-content]
=== Inaccessible immutable content

From the point of view of the definition of level 2 immutability, fields are either already level 2 immutable, or they are modifiable and the rules of level 2 immutability have to ensure that no modifications can take place.

Inside the combined object graphs of the fields of a level 2 immutable type, we can make another distinction: between those objects whose content is accessible, and those whose content is 'invisible' because they are only represented by a (typically very) shallow interface which is level 2 immutable.
In the case of unbound parameter types, as specified in <<generics>>, we chose to represent them in the type by `java.lang.Object`, or an empty interface, which is very shallow indeed.

Let's go back to the simplest definition of a `Pair`,

.Example {counter:example}, `Pair` revisited, again
[source,java]
----
@E2Container
public class Pair<K, V> {
    public final K k;
    public final V v;

    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Think of `K` and `V` as empty interfaces, which hide almost all data held by their concrete instances.
(The reason for the _almost_ is the presence, for every object, of an implementation of `toString` and `equals`, however little informative they may be.)

On the opposite end of the spectrum we find:

.Example {counter:example}, a type with fully accessible data
[source,java]
----
@E2Container
public record Coordinate(int x, int y, int z) {}
----

In `Coordinate`, all the data is readily accessible, and, because of the finality of the class, no extensions can ever be made to add more (hidden, when presented with `Coordinate`) data.

In this continuum between accessible and inaccessible, it seems impossible to draw a line, and, luckily, our definitions do not require us to do so.
The reason we bring up this point is to highlight the distinction between level 2 immutability and deep immutability:
Outside the level 2 immutable type, the inaccessible immutable content it holds need not be inaccessible, nor immutable, at all!

.Example {counter:example}, usage of `Pair`, outside its definition
[source,java]
----
Pair<StringBuilder, Integer> twoBuilders = new Pair<>(new StringBuilder("x"), 1);
twoBuilders.k.append("!");
----

In the rest of this chapter, we will attempt to catch and propagate some modifications made by concrete implementations of abstract methods.
The machinery provided in the earlier chapters will be shown to be insufficient.
Please note that characterising _all_ such modifications is a hopelessly complex, and unnecessary, task.
We will, however, need to deal with what can be seen as the first level of modifications to the immutable content, if we want to be able to characterise the modifications going on in extremely important constructs such as iterators.

=== Visitors

Let's go back to `NonEmptyImmutableList`, first defined in <<abstract-methods>>:

.Example {counter:example}, revisiting `NonEmptyImmutableList`
[source,java]
----
@E2Container
interface NonEmptyImmutableList<T> extends HasSize {

    // implicitly present: @NotModified
    @Independent
    T first();

    // implicitly present: @NotModified
    void visit(Consumer<T> consumer); // @IgnoreModifications

    @Constant
    @NotModified
    @Override
    default boolean isEmpty() {
        return false;
    }
}
----

We start the discussion with the following level 2 immutable implementation of this interface:

.Example {counter:example}, level 2 immutable implementation of `NonEmptyImmutableList`
[source,java]
----
@E2Container
class ImmutableOne<T> implements NonEmptyImmutableList<T> {
    private final T t;

    public ImmutableOne(@Dependent1 T t) { // <1>
        this.t = t;
    }

    @Override
    public int size() {
        return 1;
    }

    @Override
    public T first() {
        return t;
    }

    @Override
    public void visit(Consumer<T> consumer) {
        consumer.accept(t);
    }
}
----

<1> Annotation will be explained shortly.

We need the `visit` method (1) to be non-modifying, and (2) not to modify its parameter `consumer`.
However, following the normal definitions of modification, the following two statements hold:

1. Because `accept` is {modified}, we should mark the parameter `consumer` as {modified}.
2. Because `t`, the parameter of `accept`, is {modified}, we should mark `visit` as {modified}.

The result of the first statement would violate the `@Container` property on `ImmutableOne`, and we'd be very reluctant to do that:
according to the intuitive definition in <<containers>>, `ImmutableOne` is a type that holds data, but does not change it.
This statement still holds in the presence of a `visit` method, which is nothing but a way of exposing the object in a way similar to the method `first`.
The second one would make `visit` modifying, which again goes against our intuition: looping over elements is, in itself, not modifying.

Luckily, there are two observations that come to the rescue.

First, we believe it is correct to assume that concrete implementations of `Consumer` can be semantically unrelated to `ImmutableOne`.
As a consequence, we could say that the only modifications that concern us in this `visit` method are the modifications to `accept` 's parameter `t`.
Other modifications, for example those to the fields of the type in which the implementation is present, may be considered to be outside our scope.
However, if we replace `Consumer` with `Set` and `accept` with `add`, we encounter a modification that we really do not want to ignore, in an otherwise equal setting.
Therefore, it does not look like we can reason away potential modifications by `accept`.
We will have to revert to a contracted {ignoreModifications} annotation on the parameter `consumer`, if we want to avoid `ImmutableOne` losing the `@Container` property.

The second modification, however, is one we will ignore in the `ImmutableOne` type, and _defer_ or _propagate_ to the place where a concrete implementation of the consumer is presented.
We can ignore it here, because `t` is of level 2 immutable type; what happens to its content happens outside the zone of control of `ImmutableOne`.
The fact that _immutable content_ (properly defined shortly) is passed on as an argument to a method of `consumer` will be reflected by a {dependent1} annotation.
It will take care of the propagation of modifications from the concrete implementation into the immutable content.

This results in the following annotations for `visit` in `ImmutableOne`:

.Example {counter:example}, the `visit` method in `ImmutableOne`, fully annotated
[source,java]
----
@NotModified
public void visit(@IgnoreModifications @Dependent1 Consumer<T> consumer) {
    consumer.accept(t);
}
----

Note that we assume that we will need {ignoreModifications} for almost every use of a functional interface from `java.util.function` occurring as a parameter.
These types are for generic use; one should never use them to represent some specific data type where modifications are of concern to the current type.
Therefore, we make this annotation implicit in exactly this context.

Looking at the more general case of a `forEach` implementation iterating over a list or array, we therefore end up with:

.Example {counter:example}, a generic `forEach` implementation
[source,java]
----
@NotModified
public void forEach(@Dependent1 Consumer<T> consumer) {
    for(T t: list) consumer.accept(t);
}
----

Modifications to the parameter, made by the concrete implementation, are propagated into the immutable content of `list`, as described in the next section.
The {dependent1} annotation appears because immutable content in `list` is exposed to the `consumer` parameter.
This annotation does not appear for the modifiable content of the level 2 immutable type.
Parameters of modifiable type are already shielded from external modification by the {independent} annotation, which is "trivial" for level 2 immutable types.

=== Modifiable vs immutable content

In the following example, a field of level 2 immutable type holds explicitly mutable data:

.Example {counter:example}, a field of more complex type
[source,java]
----
@E2Container
class EncapsulatedImmutableArrayOfHasSize implements NonEmptyImmutableList<HasSize> {

    private final ImmutableOne<HasSize[]> one;

    public EncapsulatedImmutableArrayOfHasSize(int size,
            @Dependent1 Supplier<HasSize> generator) { // <1>
        HasSize[] elements = new HasSize[size];
        Arrays.setAll(elements, i -> generator.get());
        one = new ImmutableOne<>(elements);
    }

    @Override
    public int size() {
        return Arrays.stream(one.first()).mapToInt(HasSize::size).sum();
    }

    @Override
    @Dependent1
    public HasSize first() {
        return one.first()[0];
    }

    @NotModified
    public HasSize get(int index) {
        return one.first()[index];
    }

    @Override
    public void visit(@Dependent1 Consumer<HasSize> consumer) {
        for (HasSize element : one.first()) consumer.accept(element);
    }
}
----

<1> See further, in <<immutable-content-linking>>: the immutable content of this type links to the `generator` parameter.

The object graph of the field `one` consists of a level 2 immutable type (`ImmutableOne`), which in turn holds an array of level 2 immutable type objects (`HasSize`).

As an aside, we note that arrays are essentially level 1 immutable constructs: a chunk of memory is held in an effectively final field, and array access reads and writes from this memory object.
Indeed, consider the following semi-realistic implementation:

.Example {counter:example}, an array is a level 1 immutable container
[source,java]
----
@E1Container
interface Array<T> {
    int length();

    T get(int index);

    @Modified
    void set(int index, T t);
}

@E1Container
interface ConsecutiveBytes {
    int size();

    byte[] get(int pos, int n);

    @Modified
    void set(int pos, byte[] bytes);
}

@E1Container
class ArrayImpl<T> implements Array<T> {
    private static final int bytesInObject = 4;
    private final ConsecutiveBytes bytes;

    public ArrayImpl(int size) {
        bytes = new ConsecutiveBytes(size * bytesInObject);
    }

    @Override
    public int length() { return bytes.size() / bytesInObject; }

    @Override
    public T get(int i) {
        return (T) bytes.get(i * bytesInObject, bytesInObject);
    }

    @Override
    public void set(int index, T t) {
        bytes.set(index * bytesInObject, bytesInObject);
    }
}
----

Returning the to initial topic, we see that the array is not transparent (see <<generics>>) in `EncapsulatedImmutableArrayOfHasSize`:
its values are set in the constructor, and read in almost all methods.
The array clearly is modifiable, and its content is clearly level 2 immutable.

It is clear that the array belongs to the modifiable data, whilst the content of the array is part of the immutable content of the type `EncapsulatedImmutableArrayOfHasSize`.
In general,

****
The *immutable content* of a level 1 immutable type are those parts of the object graphs of the fields that are level 2 immutable, and do not contain accessible, modifiable sub-fields.
The rest of the content is called the *modifiable content* of the level 1 immutable type.
****

Why do we say level 1 immutable here?
We want to be able to use the concept of immutable content, {dependent1}, and propagation of modification in types like `Collection`, `Set` and `List`!
They will often not be level 2 immutable, yet they have a `forEach` or `visit` independent of their immutable status.
It is the modifiable content which is insufficiently shielded, or which is actively modified, that prevents a level 1 immutable type from becoming level 2 immutable.
The immutable content cannot be the differentiator between level 1 and level 2 immutable.

=== Deeply immutable types

We briefly note that the point of propagating modifications to the immutable content, the topic of this chapter, is not relevant when this immutable content is _deeply immutable_.
We have used the latter concept a few times already; now is a good time to define it formally.

A first, necessary restriction for a type to be deeply immutable is that it cannot be extended, i.e., it should be marked as `final`.
This prevents the creation of sub-types which hold data that is inaccessible to the formal parent type, yet potentially modifiable when exposed in a concrete situation, exactly as we are discussing in this chapter.
Note that the Java types that have literals associated with them, the primitives and `java.lang.String`, cannot be extended.
They will form the basis of a recursive definition.
Also note that by definition, a Java 16 `record` type cannot be extended.

The rest of the restrictions follow the rules of level 2 immutability in a remarkably similar way.
Loosely speaking, we still allow for modifiable content, as long as it is properly shielded and not modified, but we require the immutable content to be deeply immutable.
More formally,

****
A type is _deeply immutable_ when the following restrictions hold at the same time:

. the type cannot be extended (it is explicitly marked `final`)
. its fields are effectively final ({final})
. its fields are not modified ({nm})
. its fields are either private, or of deeply immutable type
. its non-private methods and constructors do not expose the non-deeply immutable content of the fields
****

It is straightforward to see that deeply immutable types are also level 2 immutable.
We will not spend more time on deeply immutable constructs, hence not elaborate on the details of rule 5.

=== Propagating modifications

Let us apply the `visit` method of `NonEmptyImmutableList` to `StringBuilder`:

.Example {counter:example}, propagating the modification of `visit`
[source,java]
----
static void print(@NotModified NonEmptyImmutableList<StringBuilder> list) {
    one.visit(System.out::println); // <1>
}

static void addNewLine(@Modified NonEmptyImmutableList<StringBuilder> list) {
    one.visit(sb -> sb.append("\n")); // <2>
}
----

<1> Non-modifying method implies no modification on the immutable content of `list`.
<2> Parameter-modifying lambda propagates a modification to `list` 's immutable content.

It is the second method, `addNewLine`, that is of importance here.
Thanks to the {dependent1} annotation, we know of a modification to `list`, even if `list` is of level 2 immutable type!
It may help to see the for-loop written out, if we temporarily assume that we have added an implementation of `Iterable` to `NonEmptyImmutableList`, functionally identical to `visit`:

.Example {counter:example}, alternative implementation of `addNewLine`
[source,java]
----
static void addNewLine(@Modified NonEmptyImmutableList<StringBuilder> list) {
    for(StringBuilder sb: list) {
      sb.append("\n"));
    }
}
----

We really need the link between `sb` and `list` for the modification on `sb` to propagate to `list`.
Without this propagation, we would not be able to implement the full definition of modification of parameters, as stipulated in <<modification>>, in this relatively straightforward, and probably frequently occurring situation.

Moving from `NonEmptyImmutableList` to `NonEmptyList`, defined <<NonEmptyList, here>>, which has a modifying method, allows us to contrast two different modifications:

.Example {counter:example}, contrasting the modification on the parameter `sb` to that on `list`
[source,java]
----
static void addNewLine(@Modified NonEmptyList<StringBuilder> list) {
    list.visit(sb -> sb.append("\n")); // <1>
}

static void replace(@Modified NonEmptyList<StringBuilder> list) {
    list.setFirst(new StringBuilder("?")); // <2>
}
----

<1> Modification to the immutable content of `list`
<2> Modification to the modifiable content of `list`

Without storing additional information (e.g., using an as yet undefined annotation like `@Modified1` on `list` in `addNewLine`), however, we cannot make the distinction between a modification to the string builders inside `list`, or a modification to `list` itself.
In other words, applying the two methods further on, we cannot

.Example {counter:example}, using `print` and `addNewLine`
[source,java]
----
static String useAddNewLine(@NotModified StringBuilder input) { // <1>
    NonEmptyList<StringBuilder> list = new One<>();
    list.setFirst(input);
    addNewLine(list);
    return list.getFirst().toString();
}

static String useReplace(@NotModified StringBuilder input) {
    NonEmptyList<StringBuilder> list = new One<>();
    list.setFirst(input);
    replace(list); // <2>
    return list.getFirst().toString();
}
----

<1> Should be {modified}, however, in the 3rd statement we cannot know that the modification is to `input` rather than to `list`
<2> This action discards `input` from `list` without modifying it.

****
The example shows that the introduction of {dependent1} only gets us so far: from the concrete, modifying implementation, to the parameter (or field).
We do not plan to keep track of the distinction between modification of immutable content vs modification of modifiable content to a further extent.
****

Finally, we mention again the modification to a field from a concrete lambda:

.Example {counter:example}, modification of a field outside the scope
[source,java]
----
List<String> strings = ...
@Modified
void addToStrings(@NotModified NonEmptyList<StringBuilder> list) {
  list.visit(sb -> strings.add(sb.toString()));
}
----

[#immutable-content-linking]
=== Immutable content linking

Going back to `ImmutableOne`, we see that the constructor links the parameter `t` to the instance's field by means of assignment.
Let us call this binding of parameters of immutable content to the field _content linking_, and mark it using {dependent1}, _content dependence_:

.Example {counter:example}, constructor of `ImmutableOne`
[source,java]
----
private final T t;

public ImmutableOne(@Dependent1 T t) {
    this.t = t;
}
----

Returning a part of the immutable content of the type, or exposing it as argument, both warrants a {dependent1} annotation:

.Example {counter:example}, more methods of `ImmutableOne`
[source,java]
----
@Dependent1
@Override
public T first() {
    return t;
}

@Override
public void visit(@Dependent1 Consumer<T> consumer) {
    consumer.accept(t);
}
----

Observe that content dependence implies 'normal' independence, as described in <<linking-and-independence>> and <<linking-formally>>, exactly because we are dealing with parameters of level 2 immutable type.

Another place where the immutable content linking can be seen, is the _for-each_ statement:

.Example {counter:example}, for-each loop and immutable content linking
[source,java]
----
ImmutableList<StringBuilder> list = ...;
List<StringBuilder> builders = ...;
for(StringBuilder sb: list) {
    builders.add(sb);
}
----

Because the `Collection` API contain an `add` method annotated as:

.Example {counter:example}, `add` in `Collection` annotated
[source,java]
----
@Modified
boolean add(@NotNull @Dependent1 E e);
----

indicating that after calling `add`, the argument will become part of the immutable content of the collection, we conclude that the local loop variable `sb` gets content linked to the `builders` list.
Similarly, this loop variable contains immutable content from the `list` object.

We reuse the annotation {dependent1} to indicate that the immutable content of two objects are linked.
Let us look at a possible implementation of `Collection.addAll`:

.Example {counter:example}, a possible implementation of `addAll` in `Collection`
[source,java]
----
@Modified
boolean addAll(@NotNull1 @Dependent1 Collection<? extends E> collection) {
    boolean modified = false;
    for (E e : c) if (add(e)) modified = true;
    return modified;
}
----

The call to `add` content links `e` to `this`.
Because `e` is also content linked to `c`, the parameter `collection` holds immutable content linked to the immutable content of the instance.

We are now properly armed to see how a for-each loop can be implemented using an iterator whose immutable content links to that of a level 1 immutable container.

=== Iterator, Iterable, loops

Let us start with the simplest definition of an iterator, without `remove` method:

.Example {counter:example}, the `Iterator` type, without `remove` method
[source,java]
----
@E1Container
interface Iterator<T> {

    @Modified
    @Dependent1
    T next();

    @Modified
    boolean hasNext();
}
----

Either the `next` method, or the `hasNext` method, must make a change to the iterator, because it has to keep track of the next element.
As such, we make both {modified}.
Following the discussion in the previous section, `next` is {dependent1}, because it returns part of the immutable content held by the iterator.

The interface `Iterable` is a supplier of iterators:

.Example {counter:example}, the `Iterable` type
[source,java]
----
@E2Container
interface Iterable<T> {

    @Dependent1
    Iterator<T> iterator();
}
----

First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a sub-type, static or not, of the type implementing `Iterable`.
Second, the iterator itself is independent of the fields of the implementing type, but has the ability to return its immutable content.

The loop, on a variable `list` of type implementing `Iterable<T>`, is expressed as `for(T t: list) { ... }`, and can be interpreted as

.Example {counter:example}, implementation of for-each using an `Iterator`
[source,java]
----
Iterator<T> it = list.iterator();
while(it.hasNext()) {
    T t = it.next();
    ...
}
----

The iterator `it` content-links to `list`; via the `next` method, it content-links the immutable content of the `list` to `t`.

[#independent-type]
=== Independence of types

A concrete implementation of an iterator is often a nested type, static or not (inner class), of the iterable type:

.Example {counter:example}, implementation of an `Iterator`
[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {

    @NotNull1
    private final T[] elements;

    @SuppressWarnings("unchecked")
    public ImmutableArray(List<T> input) {
        this.elements = (T[]) input.toArray();
    }

    @Override
    @Independent
    public Iterator<T> iterator() {
        return new IteratorImpl();
    }

    @Container
    @Independent
    class IteratorImpl implements Iterator<T> {
        private int i;

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

For `ImmutableArray` to be level 2 immutable, the `iterator()` method must be independent of the field `elements`.
How do we know this?
The implementation type `IteratorImpl` cannot be level 2 immutable, because it needs to hold the state of the iterator.
However, it should protect the fields owned by its enclosing type.
We propose to add a definition for the independence of a type, very similar to the definition of level 2 immutability:

****
*Definition*: A type is *independent* when it follows these three rules:

*Rule 1*: All constructor parameters linked to fields, and therefore all fields linked to constructor parameters, must be {nm};

*Rule 2*: All fields linked to constructor parameters must be either private or level 2 immutable;

*Rule 3*: All return values of methods must be independent of the fields linked to constructor parameters.
****

The static variant of `IteratorImpl` makes rules 1 and 2 more obvious:

.Example {counter:example}, implementation of an `Iterator` as a static nested type
[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {
    ...

    @Container
    @Independent
    static class IteratorImpl implements Iterator<T> {
        @Modified
        private int i;

        private final T[] elements;

        private IteratorImpl(T[] elements) {
            this.elements = elements;
        }

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        @Modified
        public T next() {
            return elements[i++];
        }
    }
}
----

The rules enforce that the data received from, or owned by, the enclosing type, remains properly shielded.

=== Immutable content and eventual immutability

How does the whole story of eventual level 1 or level 2 immutability mix with immutable content?
At some point, once a necessary precondition has been met, the immutable content will be well-defined, and modifying methods become unavailable.
Before that, fields that will eventually contain the immutable content may still be `null`, or may be re-assigned.
This should not have any effect, however, on the computation of immutable content linking, {dependent1} annotations, and the propagation of modifications, since the actual types do not change.
The two concepts are sufficiently perpendicular to each other, and can easily co-exist.