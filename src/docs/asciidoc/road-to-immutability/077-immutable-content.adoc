[#immutable-content]
== Immutable content

[#inaccessible-immutable-content]
=== Inaccessible immutable content

From the point of view of the definition of level 2 immutability, fields are either already level 2 immutable, or they are mutable (modifiable) and the rules of level 2 immutability have to ensure that no modifications can take place.

Inside the combined object graphs of the fields of a level 2 immutable type, we can make another distinction: between those types whose content is accessible, and those whose content is 'invisible' because they are only represented by a (typically very) shallow interface which is level 2 immutable.
In the case of unbound parameter types, as specified in <<generics>>, we chose to represent them in the type by `java.lang.Object`, or an empty interface, which is very shallow indeed.

Let's go back to the simplest definition of a `Pair`,

[source,java]
----
@E2Container
public class Pair<K, V> {
    public final K k;
    public final V v;

    public Pair(K k, V v) {
        this.k = k;
        this.v = v;
    }
}
----

Think of `K` and `V` as empty interfaces, which hide away almost all data held by any concrete instance.
(The reason for the _almost_ is the presence, for every object, of an implementation of `toString` and `equals`, however little informative they may be.)

On the opposite end of the spectrum we find:

[source,java]
----
@E2Container
public record Coordinate(int x, int y, int z) {}
----

In `Coordinate`, all the data is readily accessible, and, because of the finality of the class, no extensions can ever be made to add more (hidden, when presented with `Coordinate`) data.

In this continuum between accessible and inaccessible, it seems impossible to draw a line, and, luckily, our definitions do not require us to do so.
The reason we bring up this point is to highlight the distinction between level 2 immutability and deep immutability:
Outside the level 2 immutable type, the inaccessible immutable content need not be inaccessible, nor immutable, at all!

.Outside of _Pair_, there are no restrictions on immutability
[source,java]
----
Pair<StringBuilder, Integer> twoBuilders = new Pair<>(new StringBuilder("x"), 1);
twoBuilders.k.append("!");
----

In the rest of this chapter, we will attempt to catch and propagate some modifications made by concrete implementations of abstract methods.
The machinery provided in the earlier chapters will be shown to be insufficient.
Please note that characterising _all_ such modifications is a hopelessly complex, and unnecessary, task.
We will, however, need to deal with what can be seen as the first level of modifications to the immutable content, if we want to be able to characterise the modifications going on in extremely important constructs such as iterators.

=== Visitors

Let's go back to `NonEmptyImmutableList`, first defined in <<abstract-methods>>:

.Revisiting _NonEmptyImmutableList_
[source,java]
----
@E2Container
interface NonEmptyImmutableList<T> extends HasSize {

    // implicitly present: @NotModified
    @Independent
    T first();

    // implicitly present: @NotModified
    void visit(Consumer<T> consumer); // @IgnoreModifications

    @Constant
    @Override
    default boolean isEmpty() {
        return false;
    }
}
----

We start the discussion with the following level 2 immutable implementation of this interface:

.Level 2 immutable implementation of _NonEmptyImmutableList_
[source,java]
----
@E2Container
class ImmutableOne<T> implements NonEmptyImmutableList<T> {
    private final T t;

    public ImmutableOne(@Dependent1 T t) {
        this.t = t;
    }

    @Override
    public int size() {
        return 1;
    }

    @Override
    public T first() {
        return t;
    }

    @Override
    public void visit(Consumer<T> consumer) {
        consumer.accept(t);
    }
}
----

We need the `visit` method (1) to be non-modifying, and (2) not to modify its parameter `consumer`.
However, following the normal definitions of modification, it follows that:

1. Because `accept` is {modified}, we should mark the parameter `consumer` as {modified}.
2. Because `t`, the parameter of `accept`, is {modified}, we should mark `visit` as {modified}.

The result of the first statement would violate the `@Container` property on `ImmutableOne`, and we'd be very reluctant to do that:
according to the intuitive definition in <<containers>>, `ImmutableOne` is a type that holds data, but does not change it.
This statement still holds in the presence of a `visit` method, which is nothing but a way of exposing the object similar to `first`.
The second one would make `visit` modifying, which again goes against our intuition: looping over elements is, in itself, not modifying.

Luckily, there are a number of observations that come to the rescue.

First, we believe it is correct to assume that concrete implementation of `Consumer` can be semantically unrelated to `ImmutableOne`.
As a consequence, we could say that the only modifications that concern us in this `visit` method are the modifications to `accept` 's parameter `t`.
Other modifications, for example those to the fields of the type in which the implementation is present, may seem to be outside our scope.
However, if we replace `Consumer` with `Set` and `accept` with `add`, we encounter a modification that we do not really want to ignore, in an otherwise equal setting.
Therefore, it does not look like we can reason away potential modifications by `accept`.
We will have to revert to a contracted {ignoreModifications} annotation on the parameter `consumer`, if we want to avoid `ImmutableOne` losing the `@Container` property.

The second modification, however, is one we will ignore in the `ImmutableOne` type, and _defer_ or _propagate_ to the place where a concrete implementation of the consumer is presented.
We can ignore it here, because `t` is of level 2 immutable type; what happens to its content happens outside the zone of control of `ImmutableOne`.
The fact that immutable content is passed on as an argument to a method of `consumer` will be reflected by a {dependent1} annotation.
It will take care of the propagation of modifications from the concrete implementation into the hidden immutable content.

This results in the following annotations for `visit` in `ImmutableOne`:

.The _visit_ method in _ImmutableOne_, fully annotated
[source,java]
----
@NotModified
public void visit(@IgnoreModifications @Dependent1 Consumer<T> consumer) {
    consumer.accept(t);
}
----

Note that we assume that we will need {ignoreModifications} for almost every use of a functional interface from `java.util.function` occurring as a parameter.
These types are for generic use; one should never use them to represent some specific data type where modifications are of concern to the current type.
Therefore, we make this annotation implicit in exactly this context.

Looking at the more general case of a `forEach` implementation iterating over a list or array, we therefore end up with:

.Generic _forEach_ implementation
[source,java]
----
@NotModified
public void forEach(@Dependent1 Consumer<T> consumer) {
    for(T t: list) consumer.accept(t);
}
----

Modifications to the parameter, made by the concrete implementation, are propagated into the immutable content of `list`, as described in the next section.
The {dependent1} annotation appears because immutable content in `list` is exposed to the `consumer` parameter.
This annotation does not appear for the modifiable content of the level 2 immutable type (earlier also referred to as the _support data_).
Parameters of modifiable type are already shielded from external modification by the {independent} annotation, which is "trivial" for level 2 immutable types.

=== Modifiable content

In the following example, a field of level 2 immutable type holds explicitly mutable data:

[source,java]
----
@E2Container
class EncapsulatedImmutableArrayOfHasSize implements NonEmptyImmutableList<HasSize> {

    private final ImmutableOne<HasSize[]> one;

    public EncapsulatedImmutableArrayOfHasSize(int size,
            @Dependent1 Supplier<HasSize> generator) { // <1>
        HasSize[] elements = new HasSize[size];
        Arrays.setAll(elements, i -> generator.get());
        one = new ImmutableOne<>(elements);
    }

    @Override
    public int size() {
        return Arrays.stream(one.first()).mapToInt(HasSize::size).sum();
    }

    @Override
    @Dependent1
    public HasSize first() {
        return one.first()[0];
    }

    @NotModified
    public HasSize get(int index) {
        return one.first()[index];
    }

    @Override
    public void visit(@Dependent1 Consumer<HasSize> consumer) {
        for (HasSize element : one.first()) consumer.accept(element);
    }
}
----
<1> See further, in <<content-linking>>: the immutable content of this type links to the `generator` parameter.

The object graph of the field `one` consists of a level 2 immutable type (`ImmutableOne`), which in turn holds an array of level 2 immutable type objects (`HasSize`).

As an aside, we note that arrays are essentially level 1 immutable constructs: a chunk of memory is held in an effectively final field, and array access reads and writes from this memory object.
Indeed, consider the following semi-realistic implementation:

.An array is a level 1 immutable container
[source,java]
----
@E1Container
interface Array<T> {
    int length();

    T get(int index);

    @Modified
    void set(int index, T t);
}

@E1Container
interface ConsecutiveBytes {
    int size();

    byte[] get(int pos, int n);

    @Modified
    void set(int pos, byte[] bytes);
}

@E1Container
class ArrayImpl<T> implements Array<T> {
    private static final int bytesInObject = 4;
    private final ConsecutiveBytes bytes;

    public ArrayImpl(int size) {
        bytes = new ConsecutiveBytes(size * bytesInObject);
    }

    @Override
    public int length() { return bytes.size() / bytesInObject; }

    @Override
    public T get(int i) {
        return (T) bytes.get(i * bytesInObject, bytesInObject);
    }

    @Override
    public void set(int index, T t) {
        bytes.set(index * bytesInObject, bytesInObject);
    }
}
----

Returning the to initial topic, we see that the array is not transparent (see <<generics>>) in `EncapsulatedImmutableArrayOfHasSize`:
its values are set in the constructor, and read in almost all methods.
The array clearly is modifiable, and its content is clearly level 2 immutable.

It is clear that the array belongs to the support data or modifiable data, whilst the content of the array is part of the immutable content of the type `EncapsulatedImmutableArrayOfHasSize`.

We state that the `one` object, which holds the array, belongs to the support data.
In general,

****
The *immutable content* of a level 1 immutable type are those parts of the object graphs of the fields that are level 2 immutable, and do not contain accessible, modifiable sub-fields.
The rest of the content is called the *modifiable content* of the level 1 immutable type.
In the case of a level 2 immutable type, we have occasionally called the modifiable content *support data*.
****

Why do we say level 1 immutable here?
We want to be able to use the concept of immutable content, {dependent1}, and propagation of modification in types like `Collection`, `Set` and `List`!
They will often not be level 2 immutable, yet they have a `forEach` or `visit` independent of their immutable status.
It is the modifiable content which is insufficiently shielded, or which is actively modified, that prevents a level 1 immutable type from becoming level 2 immutable.
The immutable content cannot be the differentiator between level 1 and level 2 immutable.

=== Constant content

We briefly note that the point of propagating modifications on the immutable content, the topic of this chapter, is not relevant when this immutable content is deeply immutable.
It is even more irrelevant when the content is _constant_:

****
A type is _constant_ when the following both hold:

. the type cannot be extended (it is explicitly marked `final`), and
. recursively defined, its fields are effectively final and hold constant values, and its methods return constant values.
The basis for the recursion are the primitives and `java.lang.String`, holding literal constant values.
****

Apart from mentioning it occasionally, we do not want to spend too much time on deeply immutable constructs.

=== Propagating modifications

Let us apply the `visit` method of `NonEmptyImmutableList` to `StringBuilder`:

.Propagating the modification of _visit_
[source,java]
----
static void print(@NotModified ImmutableOne<StringBuilder> one) {
    one.visit(System.out::println); // <1>
}

static void addNewLine(@Modified ImmutableOne<StringBuilder> one) {
    one.visit(sb -> sb.append("\n")); // <2>
}
----
<1> Non-modifying method implies no modification on the hidden immutable content of `c`.
<2> Parameter-modifying lambda propagates modification to `c` 's hidden immutable content.

Having placed the `ImmutableOne` object `one` as a parameter, we are certain that the modification annotation catches any modification to the whole object graph, including those to inaccessible content

[source,java]
----
static void replace(@Modified ImmutableO<StringBuilder> c) {
    one.visit(sb -> c.add(new StringBuilder("x" + sb))); // <3>
}

List<String> strings = ...
@Modified // <4>
void addToStrings(@NotModified Circular<StringBuilder> c) {
c.forEach(sb -> strings.add(sb.toString()));
}
----
<3> Object-modifying lambda changing `c` but not its content (the string builder it holds).
<4> Example of modification to fields outside the scope of `Circular`.

It is item 2, `addNewLine`, that is of importance here.
Thanks to the {dependent1} annotation, we know of a modification to `c`.
It helps to see the for-loop written out, if we temporarily assume that we have added an implementation of `Iterable` to `Circular`:

[source,java]
----
static void addNewLine(@Modified Circular<StringBuilder> c) {
    for(StringBuilder sb: c) {
      sb.append("\n"));
    }
}
----

We really need the link between `sb` and `c` for the modification on `sb` to propagate to `c`.

Without storing additional information (e.g., using an as yet undefined annotation like `@Modified1` on `c` in `addNewLine`), however, we cannot make the distinction between a modification to the string builders inside `x` and `y`, or an assignment to `x` or `y` in `Circular`, as in item 3.
In other words, we cannot determine {m} on the parameters of `useAddNewLine` in the following example:

.Using print and addNewLine
[source,java]
----
static String usePrint(@NotModified StringBuilder sb1,
                       @NotModified StringBuilder sb2,
                       @NotModified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1); // <1>
    circular.add(sb2);
    circular.add(sb3);
    print(circular);
    return circular.stream().collect(Collectors.joining());
}

static String useAddNewLine(@Modified StringBuilder sb1, //<2>
                            @Modified StringBuilder sb2,
                            @Modified StringBuilder sb3) {
    Circular<StringBuilder> circular = new Circular<>();
    circular.add(sb1);
    circular.add(sb2);
    circular.add(sb3);
    addNewLine(circular); // <3>
    return circular.stream().collect(Collectors.joining());
}
----
<1> `circular` now holds `sb1`
<2> impossible to determine
<3> The {modified} on `addNewLine` implies that `circular` has been modified, but we do not know if any of `sb1`, `sb2`, `sb3` has been affected.

[#content-linking]
=== Content linking

Going back to `Circular`, we see that the `add` method binds the parameter `t` to the instance by means of assignment.
Let us call this binding of parameters of hidden immutable types _content linking_, and mark it using {dependent1}, _content dependence_:

.Extra annotation on add
[source,java]
----
@Modified
public void add(@Dependent1 T t) {
    if (next) {
        this.y = t;
    } else {
        this.x = t;
    }
    next = !next;
}
----

Note that content dependence implies normal independence, exactly because we are dealing with parameters of hidden immutable type.
Thanks to this annotation, the statement `circular.add(sb1)` can content link `sb1` to circular.
When propagating the modification of `addNewLine` 's parameter, all variables content linked to the argument get marked.

A second way, next to assignment, of adding to content links is Java's for-each loop:

.For-each loop and content linking
[source,java]
----
Collection<StringBuilder> builders = ...;
for(StringBuilder sb: builders) { circular.add(sb); }
----

The local loop variable `sb` gets content linked to `circular`.
Crucially, however, it is not difficult to see that `sb` is also content linked to `builders`!
The `Collection` API will contain an `add` method annotated as:

[source,java]
----
@Modified
boolean add(@NotNull @Dependent1 E e) { return true; }
----

indicating that after calling `add`, the argument will become part of the hidden immutable content of the collection.
We reuse the annotation {dependent1} to indicate that the hidden immutable content of two objects are linked.
Looking at a possible implementation of `addAll`:

.addAll
[source,java]
----
@Modified
boolean addAll(@NotNull1 @Dependent1 Collection<? extends E> collection) {
    boolean modified = false;
    for (E e : c) if (add(e)) modified = true;
    return modified;
}
----

The call to `add` content links `e` to `this`.
Because `e` is also content linked to `c`, the parameter `collection`
holds hidden immutable content linked to the hidden immutable content of the instance.

Again, note that {dependent1} implies independence, because it deals with the hidden immutable content.

We're now properly armed to see how a for-each loop can be defined as an iterator whose hidden immutable content links to that of a container.

=== Iterator, Iterable, loops

Let us start with the simplest definition of an iterator, without `remove` method:

.Iterator, without remove
[source,java]
----
interface Iterator<T> {

    @Modified
    @Dependent1
    T next();

    @Modified
    boolean hasNext();
}
----

Either the `next` method, or the `hasNext` method, must make a change to the iterator, because it has to keep track of the next element.
As such, we make both {modified}.
Following the discussion in the previous section, `next` is {dependent1}, because it returns part of the hidden immutable content held by the iterator.

The interface `Iterable` is a supplier of iterators:

.Iterable
[source,java]
----
interface Iterable<T> {

    @NotModified
    @Dependent1
    Iterator<T> iterator();
}
----

First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a sub-type, static or not, of the type implementing `Iterable`.
Secondly, the iterator itself is independent of the fields of the implementing type, but has the ability to return its hidden immutable content.

The loop, on a variable `list` of type implementing `Iterable<T>`,

[source,java]
----
for(T t: list) { ... }
----

can be interpreted as

[source,java]
----
Iterator<T> iterator = list.iterator();
while(it.hasNext()) {
    T t = it.next();
    ...
}
----

The iterator is {dependent1}.
Via the `next` method, it content-links the hidden immutable content of the `list` to `t`.

=== Independence of types

A concrete implementation of an iterator is a sub-type, static or not, of the iterable type:

[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {

    @NotNull1
    private final T[] elements;

    @SuppressWarnings("unchecked")
    public ImmutableArray(List<T> input) {
        this.elements = (T[]) input.toArray();
    }

    @Override
    @Independent
    public Iterator<T> iterator() {
        return new IteratorImpl();
    }

    @Container
    @Independent
    class IteratorImpl implements Iterator<T> {
        private int i;

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----

For `ImmutableArray` to be level 2 immutable, the `iterator()` method must be independent of the field `elements`.
How do we know this?
The implementation type `IteratorImpl` cannot be level 2 immutable, because it needs to hold the state of the iterator.
However, it should protect the fields of its enclosing type.
We propose to add a definition for the independence of a type, very similar to the one enforced for level 2 immutability:

****
*Definition*: A type is *independent* when it follows these three rules:

*Rule 1*: All constructor parameters linked to fields, and therefore all fields linked to constructor parameters, must be {nm};

*Rule 2*: All fields linked to constructor parameters must be either private or level 2 immutable;

*Rule 3*: All return values of methods must be independent of the fields linked to constructor parameters.
****

The static variant of `IteratorImpl` makes rules 1 and 2 more obvious:

.Static iterator implementation
[source,java]
----
@E2Container
public class ImmutableArray<T> implements Iterable<T> {
    ...

    @Container
    @Independent
    static class IteratorImpl implements Iterator<T> {
        private int i;
        private final T[] elements;

        private IteratorImpl(T[] elements) {
            this.elements = elements;
        }

        @Override
        public boolean hasNext() {
            return i < elements.length;
        }

        @Override
        @NotNull
        public T next() {
            return elements[i++];
        }
    }
}
----
