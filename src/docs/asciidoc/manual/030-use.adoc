
== Using e2immu

=== Basic use

Starting your first project, basic use of the {e2immu} analyser looks like

image::e2immu_basic_use.png[title="Basic use of e2immu",id="basic-use"]

Having installed {e2immu}'s IntelliJ IDEA plugin, and having started a local annotation server, you can edit your project, occasionally run the analyser, and make use of pre-annotated libraries.

The analyser produces computed annotations, errors and warnings, which you can of course read from the command line.
It also pushes these errors, warnings, and computed annotations to the annotation server, which is continuously consulted by the highlighter plugin.
So while you're working on your project, each time you run the analyser, your editor is updated.
We're suggesting that you confirm critical annotations in the source code.
They will get the annotation type `VERIFY` which is the default for source code read by the analyser, they allow you to 'stabilize' your code with respect to class types like {container} or
{e2immutable}.

This set-up will get you pretty far, as long as

- your project consists of a single set of source files
- all the libraries you are using have been pre-annotated.

=== Full flow

The {e2immu} analyser is set up to read, in order of decreasing priority,

. the source code of your project
. annotated API sources, as a replacement for class files with XML annotations
. class files and associated XML annotation files from jars, for libraries used in your project

If your project is or becomes a library for other projects to use, the computed annotations have to be made available to the users of the library:

. for fast turn-around development on your own or in small teams, you can use the analyser run on the library.
This is depicted in <<figure-fast-turnaround>>.
to upload computed annotations to the annotation store, and instruct the analyser on the project consuming the library to consult this store.
For this purpose, the annotation store has the ability to store annotations in user-defined _projects_; the analyser can read from any such _projects_.
. the standard procedure is for the computed annotations to be included in the `jar` file of the project:
the analyser can directly write `annotations.xml` files in the resources of your project, one for each package.
This action can take place after the compilation phase and before the packaging phase in you build tool. {e2immu} provides a plugin for Gradle for now.
This flow is depicted in <<figure-annotated-xml-via-gradle>>.

image::e2immu_fast_turnaround.png[title="Fast turnaround use of e2immu",id="figure-fast-turnaround"]

image::e2immu_annotated_xml_via_gradle.png[title="Add annotation.xml files to your jar",id="figure-annotated-xml-via-gradle"]

If you are annotating external libraries with {e2immu} annotations, there are two options

. you can use the _external annotations_ feature of IntelliJ IDEA to create annotations files.
These files are best grouped into a new jar file, on per library, which is to be included in the dependencies of your project.
. you can use annotated API sources, a kind of Java source file which contains all the declarative aspects of the types you'll be using.
These files are quick to create, provide a nice overview, and can be used in combination with the underlying JAR so that you only have to copy those declarations that you want to annotate.
Their main advantage is clarity: all types, fields, and methods _relevant to you_ are close together, with their annotations

Annotated API sources can be generated by the analyser from jars and XML annotations, presenting only those types, methods and fields that your project is using.

Updated annotation files can be generated by the analyser from the combination of annotated API sources and existing annotation files.
